/**
 * @fileoverview Firestore Security Rules for QuizMasterAI.
 *
 * Core Philosophy: This ruleset enforces a strict user-ownership model for user profiles and quizzes.
 * Quiz attempts are stored in a root collection to allow creators to view results, secured by checking the quiz's authorId.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only by the user themselves.
 * - /users/{userId}/quizzes/{quizId}: Quizzes created by the user.
 * - /quizzes/{quizId}: Public collection for sharing quizzes. Anyone can read by ID.
 * - /users/{userId}/quiz_attempts/{quizAttemptId}: A user's own history of attempts.
 * - /quiz_attempts/{quizAttemptId}: Root collection for all attempts, used for creator dashboards.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Write operations are protected by an authorization check.
 * - Quiz creators can read attempts for their own quizzes from the root collection.
 * - Users can read and write to their own private attempt history.
 * - Public quizzes collection: Anyone can read by ID, only author can create/update/delete.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Helper function to check if user can access a quiz attempt
    // Users can access attempts if they took the quiz (userId matches) OR created the quiz (authorId matches)
    function canAccessAttempt(attemptData) {
      return isSignedIn() && 
        (attemptData.userId == request.auth.uid || attemptData.authorId == request.auth.uid);
    }

    match /users/{userId} {
      allow get, update, delete: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;

      match /quizzes/{quizId} {
        allow list, get: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.authorId == userId;
        allow update, delete: if isOwner(userId) && resource.data.authorId == userId;

        // Questions are part of the quiz document, so they inherit parent rules.
        // If they were a sub-collection, they'd need their own rules.
      }
      
      // A user can manage their own history of attempts
      match /quiz_attempts/{attemptId} {
        allow read, write: if isOwner(userId);
      }
    }

    // Public quizzes collection for sharing
    match /quizzes/{quizId} {
      // Anyone can read quizzes by ID (for shared links)
      allow get: if true;
      // Only the author can create, update, or delete their quizzes
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
      // Disallow listing to prevent enumeration
      allow list: if false;
    }

    match /quiz_attempts/{attemptId} {
      // Allow authenticated users to list quiz attempts
      // Firestore evaluates each document in the result against the 'get' rule below
      // This allows queries that filter by authorId (for quiz creators) or userId (for students)
      // The 'get' rule ensures only authorized documents are returned
      allow list: if request.auth != null;
      
      // Allow anyone (including anonymous users) to create quiz attempts
      // This is necessary because students may take quizzes without being authenticated
      // The userId field can be 'anonymous' for unauthenticated users
      // Validation: Ensure required fields are present and valid
      allow create: if request.resource.data.keys().hasAll([
                      'id', 'quizId', 'quizTitle', 'userId', 'userName', 
                      'studentName', 'registrationNumber', 'authorId', 
                      'answers', 'score', 'startedAt', 'completedAt', 
                      'violations', 'isFlagged'
                    ])
                    && request.resource.data.studentName is string
                    && request.resource.data.registrationNumber is string
                    && request.resource.data.authorId is string
                    && request.resource.data.quizId is string
                    && request.resource.data.quizTitle is string
                    && request.resource.data.userId is string
                    && request.resource.data.userName is string
                    && request.resource.data.score is int
                    && request.resource.data.violations is int
                    && request.resource.data.isFlagged is bool
                    && request.resource.data.startedAt is string
                    && request.resource.data.completedAt is string
                    && request.resource.data.studentName.size() > 0
                    && request.resource.data.registrationNumber.size() > 0
                    && request.resource.data.score >= 0
                    && request.resource.data.score <= 100
                    && request.resource.data.violations >= 0;
      
      // Allow a user to read (get) an existing attempt if:
      // - The 'userId' field matches their UID (they took the quiz), OR
      // - The 'authorId' field matches their UID (they created the quiz)
      // CRITICAL: For list queries, Firestore evaluates this rule for EACH document in the result.
      // If the query filters by authorId, all returned documents will have authorId == user.uid,
      // so they will pass this check. Same for userId.
      allow get: if canAccessAttempt(resource.data);
      
      // Allow update and delete with same conditions as get
      // Users can update their own attempts or quiz authors can update attempts for their quizzes
      // Ensure critical fields cannot be modified
      allow update: if canAccessAttempt(resource.data)
        // Prevent modification of critical fields
        && request.resource.data.id == resource.data.id
        && request.resource.data.quizId == resource.data.quizId
        && request.resource.data.authorId == resource.data.authorId
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.startedAt == resource.data.startedAt
        // Validate updated fields
        && request.resource.data.score is int
        && request.resource.data.score >= 0
        && request.resource.data.score <= 100
        && request.resource.data.violations is int
        && request.resource.data.violations >= 0
        && request.resource.data.isFlagged is bool;
      
      allow delete: if canAccessAttempt(resource.data);
    }
  }
}
